<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <style>
    body {
      font-family: monospace;
    }
    
    .k {
      position: absolute;
      left: 10px;
      top: 10px;
    }
    
    .k span {
      position: relative;
      bottom: 7px;
      padding: 0 10px;
    }
    
    .hull {
      fill: tomato;
      fill-opacity: 0.25;
      stroke: tomato;
      pointer-events: none;
    }
  </style>
</head>
<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>


<!-- Create a div where the graph will take place -->
<div id="my_dataviz">

  
</div>
<div class="ui-widget">


  <input id = "kneighbors" type="search" placeholder="Number of nearest neighbors..." required>
  <input id= "knear_start"class="Knear" type="button" value="Find Decision Boundary"><br>


</div>

<script>

var k=5

d3.select("#knear_start").on("click", function() {

  // k = +kDiv.select("input").node().value;
  //         d3.select(this).select("span").text("K = " + k);
  //         findNearest.k(k);
  var k_number = d3.select("#kneighbors").node().value;

  console.log("made it here");
  console.log(k_number);
  k=k_number;
  return findNearest.k(k_number);
})

// set the dimensions and margins of the graph
var margin = {top: 10, right: 30, bottom: 30, left: 60},
    width = 460 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
 



  svg.append("rect")
  .attr("width", width)
  .attr("height", height)
  .style("fill-opacity", 0)
  .on("mousemove", mousemove)
  
//Read the data
data=[]
//d3.csv("data/moons.csv", function(data) {
d3.csv("test.csv", function(data_points) {


for (var i=0 ;i<data_points.length;i++)
{
  data.push({x : data_points[i].x1, y : data_points[i].x2, class : data_points[i].label});
}

// console.log(data)

  // Add X axis
  var x = d3.scaleLinear()
    .domain([-2,2])
    .range([ 0, width ]);
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x));

  // Add Y axis
  var y = d3.scaleLinear()
    .domain([-2,2])
    .range([ height, 0]);
  svg.append("g")
    .call(d3.axisLeft(y));



  var color = d3.scaleOrdinal(d3.schemeCategory10)
  .domain([0, 1]);    
  // Add dots
  svg.append('g')
    .selectAll("dot")
    .data(data_points)
    .enter()
    .append("circle")
      .attr("cx", function (d) { return x(d.x1); } )
      .attr("cy", function (d) { return y(d.x2); } )
      .attr("r", 1.5)
      .style("fill", function(d){return color(d.label); })


})









d3.kNearestNeighbors = function() {
    var points = [],
        nodes,
        extent = null,
        k = 1
        
        var quadtree = d3.quadtree()
        .x(function(d) {
            return d.x
        })
        .y(function(d) {
            return d.y
        })
    function findNearest(point) {
      
      // TODO: make this more efficient by not recalculating quadtree at
      //       each call of findNearest()
      
      // Extract points from the data array
      points = data.map(function(d) { return [x(d), y(d)]; });
      // console.log(data.map(function(d) { return [x(d), y(d)]; }));
      
      // Add quadtree info to the points
      nodes = quadtreeify(points);
        // console.log(nodes);
      // Flag k-nearest points by adding `selected` property set to `true`
      
      
      // console.log(new Array(nodes));
      kNearest(new Array(nodes), [], point);
      
      // Return nearest points along with indices from origianl `data` array
      return points
        .map(function(d, i) {
          var datum = [d[0], d[1]];
          datum.i = i;
          return d.selected ? datum : null; 
        })
        .filter(function(d) { return d !== null; });
    }
    
    findNearest.extent = function(_) {
      if (!arguments.length) return extent;
      extent = _;
    //   quadtree.extent(extent);
      return findNearest;
    };
    
    findNearest.data = function(_) {
      if (!arguments.length) return data;
      data = _;
      return findNearest;
    };
    
    findNearest.k = function(_) {
      if (!arguments.length) return k;
      k = _;
      return findNearest;
    };
    
    findNearest.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return findNearest;
    };
    
    findNearest.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return findNearest;
    };
    
    return findNearest;
    
    // Add quadtree information to each point (i.e., rectangles, depth, ...)
    function quadtreeify(points) 
    {
    
        var nodes = d3.quadtree().addAll(points);
        // console.log(nodes);
        nodes.depth = 0;
        // nodes.visit(function(node, x1, y1, x2, y2)
        //   {

        //   for (var i = 0; i < 4; i++) {
        //     if (!node.length)
        //     {
        //     node.next.depth = node.depth + 1;
        //     }
        //   }
        // });
            quadtree.visit((node, x1, y1, x2, y2) => {
              if (!node.length) {
                do {
                    node.x1 = x1;
                    node.y1 = y1;
                    node.x2 = x2;
                    node.y2 = y2;
                    node.depth = node.depth + 1;
               
                } while (node = node.next);
              }
            });
        return nodes;

    }
    
    // calculate the euclidean distance of two points with coordinates a(ax, ay) and b(bx, by)
    function euclideanDistance(ax, ay, bx, by) {
      return Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));
    }
    
    // calculate minimum distance between search point rectangles
    function minDistance(x, y, x1, y1, x2, y2) {
      var dx1 = x - x1,
          dx2 = x - x2,
          dy1 = y - y1,
          dy2 = y - y2;
      
      // x is between x1 and x2
      if (dx1 * dx2 < 0) {
        // (x, y) is inside the rectangle
        if (dy1 * dy2 < 0) {
          return 0; // return 0 as a point in the rectangle
        }
        return Math.min(Math.abs(dy1), Math.abs(dy2));
      }
      
      // y is between y1 and y2 (and not inside rectangle)
      if (dy1 * dy2 < 0) {
        return Math.min(Math.abs(dx1), Math.abs(dx2));
      }
      return Math.min( 
        Math.min(euclideanDistance(x,y,x1,y1), euclideanDistance(x,y,x2,y2)), 
        Math.min(euclideanDistance(x,y,x1,y2), euclideanDistance(x,y,x2,y1))
      );
    }
    
    // Find the nodes within the specified rectangle (used recursively)
    function kNearest(bestQueue, resultQueue, point) {
      var x = point[0],
          y = point[1];
          console.log(bestQueue)
      // sort children according to their minDistance/euclideanDistance to search point
      bestQueue.sort(function(a, b) {
        console.log("here")
        // add minDistance to nodes if not there already
        [a, b].forEach(function(d) {
          if (d.minDistance === undefined) {
            d.scanned = true;
            if (d.leaf) {
              d.point.scanned = true;
              d.minDistance = euclideanDistance(x, y, d.x, d.y);
            }
            else {
              d.minDistance = minDistance(x, y, d.x1, d.y1, d.x2, d.y2);
            }
          }
        });
        return b.minDistance - a.minDistance;
      });
      
      // add nearest leafs (if any)
      for (var i = bestQueue.length - 1; i >= 0; i--) {
        console.log(k)
        var elem = bestQueue[i];
        console.log(elem.leaf)
        if (elem.leaf) {
          elem.point.selected = true;
          bestQueue.pop();
          resultQueue.push(elem);
          console.log(resultQueue)
        } else { break; }
        if (resultQueue.length >= k) break;
      }
      
      // check if enough points found
      if (resultQueue.length >= k || bestQueue.length == 0) { return; }
      else {
        console.log(bestQueue)
        // ...otherwise add child nodes to bestQueue and recurse
        var visitedNode = bestQueue.pop();
        visitedNode.visited = true;
        visitedNode.nodes.forEach(function(d) {
          bestQueue.push(d);
        });
        kNearest(bestQueue, resultQueue, point);
      }
    }
  }
var findNearest = d3.kNearestNeighbors()
        .extent([[-1, -1], [width + 1, height + 1]])
        .x(function(d) { return d.x; })
        .y(function(d) { return d.y; })
        .k(k)
        .data(data);
var hull = svg.append("path").attr("class", "hull");       

function mousemove() 
{
        preventDefault(event);
        
        var nearest = findNearest(d3.mouse(this));
        
        // Draw convex hull around k-nearest points (if k > 1)
        hull.datum(d3.geom.hull(nearest))
          .attr("d", function(d) { 
            return d.length > 1 ? "M" + d.join("L") + "Z" : null; 
          });
       
        // Get corresponding "nearest" data points from original data array 
        nearest = nearest
          .map(function(d) { return data[d.i]; });
        
        // Color nearest points red
        circles
          .style("fill", function(d) {
            return nearest.indexOf(d) !== -1 ? "red" : null;
          });
      }
      
      function clamp(d, min, max) {
        return d < min ? min : d > max ? max : d;
      }
      
      function preventDefault(e) {
        e = e || window.event;
        if (e.preventDefault) e.preventDefault();
        e.returnValue = false;  
      }











  
</script>
